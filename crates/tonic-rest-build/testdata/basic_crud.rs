// Auto-generated REST routes from proto `google.api.http` annotations.
//
// **Do not edit** — regenerated by `build.rs` when proto files change.
//
// Each handler transcodes HTTP/JSON <-> proto and calls the Tonic service trait,
// sharing auth, validation, and business logic with gRPC handlers.

use std::sync::Arc;

use axum::extract::{Json, Path, Query, State};
use axum::http::{HeaderMap, StatusCode};
use axum::Router;

// =============================================================================
// ItemService REST routes
// =============================================================================

/// Build Axum REST routes for `ItemService`.
///
/// Generated from `google.api.http` annotations in `test.proto`.
pub fn item_service_rest_router<S>(service: Arc<S>) -> Router
where
    S: crate::test::item_service_server::ItemService + Send + Sync + 'static,
{
    Router::new()
        .route("/v1/items", axum::routing::post(rest_item_service_create_item::<S>))
        .route("/v1/items/{item_id}", axum::routing::get(rest_item_service_get_item::<S>))
        .route("/v1/items/{item_id}", axum::routing::delete(rest_item_service_delete_item::<S>))
        .with_state(service)
}

/// `CreateItem` — JSON endpoint.
///
/// `POST /v1/items`
async fn rest_item_service_create_item<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    Json(body): Json<crate::test::CreateItemRequest>,
) -> Result<Json<crate::test::Item>, tonic_rest::RestError>
where
    S: crate::test::item_service_server::ItemService + Send + Sync + 'static,
{
    let req = tonic_rest::build_tonic_request::<_, ()>(body, &headers, None);
    let response = service.create_item(req).await.map_err(tonic_rest::RestError::from)?;
    Ok(Json(response.into_inner()))
}

/// `GetItem` — JSON endpoint.
///
/// `GET /v1/items/{item_id}`
async fn rest_item_service_get_item<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    Path(item_id): Path<String>,
    Query(mut body): Query<crate::test::GetItemRequest>,
) -> Result<Json<crate::test::Item>, tonic_rest::RestError>
where
    S: crate::test::item_service_server::ItemService + Send + Sync + 'static,
{
    body.item_id = item_id;
    let req = tonic_rest::build_tonic_request::<_, ()>(body, &headers, None);
    let response = service.get_item(req).await.map_err(tonic_rest::RestError::from)?;
    Ok(Json(response.into_inner()))
}

/// `DeleteItem` — JSON endpoint.
///
/// `DELETE /v1/items/{item_id}`
async fn rest_item_service_delete_item<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    Path(item_id): Path<String>,
) -> Result<StatusCode, tonic_rest::RestError>
where
    S: crate::test::item_service_server::ItemService + Send + Sync + 'static,
{
    let mut body = crate::test::DeleteItemRequest::default();
    body.item_id = item_id;
    let req = tonic_rest::build_tonic_request::<_, ()>(body, &headers, None);
    service.delete_item(req).await.map_err(tonic_rest::RestError::from)?;
    Ok(StatusCode::NO_CONTENT)
}


// =============================================================================
// Public REST paths (bypass auth middleware)
// =============================================================================

/// REST paths that are marked as public (no authentication required).
///
/// Auto-generated from `google.api.http` annotations on public RPC methods.
/// Used by middleware to identify unauthenticated endpoints.
pub const PUBLIC_REST_PATHS: &[&str] = &[
    "/v1/items",
];

// =============================================================================
// Combined REST router
// =============================================================================

/// Build a combined Axum router with REST routes for all proto services.
///
/// Each service is generic — pass your concrete implementations as `Arc<T>`.
pub fn all_rest_routes<S0>(
    item_service: Arc<S0>,
) -> Router
where
    S0: crate::test::item_service_server::ItemService + Send + Sync + 'static,
{
    Router::new()
        .merge(item_service_rest_router(item_service))
}
