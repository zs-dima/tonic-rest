// Auto-generated REST routes from proto `google.api.http` annotations.
//
// **Do not edit** — regenerated by `build.rs` when proto files change.
//
// Each handler transcodes HTTP/JSON <-> proto and calls the Tonic service trait,
// sharing auth, validation, and business logic with gRPC handlers.

use std::convert::Infallible;
use std::sync::Arc;
use std::time::Duration;

use axum::extract::{Json, Query, State};
use axum::http::HeaderMap;
use axum::response::sse::{Event, KeepAlive, Sse};
use axum::Router;
use futures::stream::{Stream, StreamExt};

// =============================================================================
// AuthService REST routes
// =============================================================================

/// Build Axum REST routes for `AuthService`.
///
/// Generated from `google.api.http` annotations in `auth.proto`.
pub fn auth_service_rest_router<S>(service: Arc<S>) -> Router
where
    S: crate::auth::auth_service_server::AuthService + Send + Sync + 'static,
{
    Router::new()
        .route("/v1/auth/login", axum::routing::post(rest_auth_service_login::<S>))
        .with_state(service)
}

#[expect(clippy::too_many_arguments, clippy::needless_pass_by_value)]
/// `Login` — JSON endpoint.
///
/// `POST /v1/auth/login`
async fn rest_auth_service_login<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    Json(body): Json<crate::auth::LoginRequest>,
) -> Result<Json<crate::auth::LoginResponse>, tonic_rest::RestError>
where
    S: crate::auth::auth_service_server::AuthService + Send + Sync + 'static,
{
    let req = tonic_rest::build_tonic_request::<_, ()>(body, &headers, None);
    let response = service.login(req).await.map_err(tonic_rest::RestError::from)?;
    Ok(Json(response.into_inner()))
}

// =============================================================================
// UserService REST routes
// =============================================================================

/// Build Axum REST routes for `UserService`.
///
/// Generated from `google.api.http` annotations in `users.proto`.
pub fn user_service_rest_router<S>(service: Arc<S>) -> Router
where
    S: crate::users::user_service_server::UserService + Send + Sync + 'static,
{
    Router::new()
        .route("/v1/users", axum::routing::get(rest_user_service_list_users::<S>))
        .with_state(service)
}

#[expect(clippy::too_many_arguments, clippy::needless_pass_by_value)]
/// `ListUsers` — SSE streaming endpoint.
///
/// `GET /v1/users` → `text/event-stream`
async fn rest_user_service_list_users<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    Query(query): Query<crate::users::ListUsersRequest>,
) -> Result<Sse<impl Stream<Item = Result<Event, Infallible>>>, tonic_rest::RestError>
where
    S: crate::users::user_service_server::UserService + Send + Sync + 'static,
{
    let req = tonic_rest::build_tonic_request::<_, ()>(query, &headers, None);
    let response = service.list_users(req).await.map_err(tonic_rest::RestError::from)?;
    let stream = response.into_inner();

    let sse_stream = stream.map(|result| {
        Ok::<_, Infallible>(match result {
            Ok(item) => Event::default()
                .json_data(&item)
                .unwrap_or_else(|_| Event::default().data("{}")),
            Err(status) => tonic_rest::sse_error_event(&status),
        })
    });

    Ok(Sse::new(sse_stream).keep_alive(
        KeepAlive::new()
            .interval(Duration::from_secs(15))
            .text("keep-alive"),
    ))
}


// =============================================================================
// Public REST paths (bypass auth middleware)
// =============================================================================

/// REST paths that are marked as public (no authentication required).
///
/// Auto-generated from `google.api.http` annotations on public RPC methods.
/// Used by middleware to identify unauthenticated endpoints.
pub const PUBLIC_REST_PATHS: &[&str] = &[
    "/v1/auth/login",
];

// =============================================================================
// Combined REST router
// =============================================================================

/// Build a combined Axum router with REST routes for all proto services.
///
/// Each service is generic — pass your concrete implementations as `Arc<T>`.
pub fn all_rest_routes<S0, S1>(
    auth_service: Arc<S0>,
    user_service: Arc<S1>,
) -> Router
where
    S0: crate::auth::auth_service_server::AuthService + Send + Sync + 'static,
    S1: crate::users::user_service_server::UserService + Send + Sync + 'static,
{
    Router::new()
        .merge(auth_service_rest_router(auth_service))
        .merge(user_service_rest_router(user_service))
}
