// Auto-generated REST routes from proto `google.api.http` annotations.
//
// **Do not edit** — regenerated by `build.rs` when proto files change.
//
// Each handler transcodes HTTP/JSON <-> proto and calls the Tonic service trait,
// sharing auth, validation, and business logic with gRPC handlers.

use std::convert::Infallible;
use std::sync::Arc;
use std::time::Duration;

use axum::extract::{Extension, Json, Path, Query, State};
use axum::http::HeaderMap;
use axum::response::sse::{Event, KeepAlive, Sse};
use axum::Router;
use futures::stream::{Stream, StreamExt};

// =============================================================================
// EventService REST routes
// =============================================================================

/// Build Axum REST routes for `EventService`.
///
/// Generated from `google.api.http` annotations in `test.proto`.
pub fn event_service_rest_router<S>(service: Arc<S>) -> Router
where
    S: crate::test::event_service_server::EventService + Send + Sync + 'static,
{
    Router::new()
        .route("/v1/events", axum::routing::get(rest_event_service_list_events::<S>))
        .route("/v1/users/{user_id_value}", axum::routing::patch(rest_event_service_update_user::<S>))
        .with_state(service)
}

/// `ListEvents` — SSE streaming endpoint.
///
/// `GET /v1/events` → `text/event-stream`
async fn rest_event_service_list_events<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    ext: Option<Extension<crate::AuthInfo>>,
    Query(query): Query<crate::test::ListEventsRequest>,
) -> Result<Sse<impl Stream<Item = Result<Event, Infallible>>>, tonic_rest::RestError>
where
    S: crate::test::event_service_server::EventService + Send + Sync + 'static,
{
    let ext = ext.map(|Extension(v)| v);
    let req = tonic_rest::build_tonic_request(query, &headers, ext);
    let response = service.list_events(req).await.map_err(tonic_rest::RestError::from)?;
    let stream = response.into_inner();

    let sse_stream = stream.map(|result| {
        Ok::<_, Infallible>(match result {
            Ok(item) => Event::default()
                .json_data(&item)
                .unwrap_or_else(|_| Event::default().data("{}")),
            Err(status) => tonic_rest::sse_error_event(&status),
        })
    });

    Ok(Sse::new(sse_stream).keep_alive(
        KeepAlive::new()
            .interval(Duration::from_secs(30))
            .text("keep-alive"),
    ))
}

/// `UpdateUser` — JSON endpoint.
///
/// `PATCH /v1/users/{user_id.value}`
async fn rest_event_service_update_user<S>(
    State(service): State<Arc<S>>,
    headers: HeaderMap,
    ext: Option<Extension<crate::AuthInfo>>,
    Path(user_id_value): Path<String>,
    Json(mut body): Json<crate::test::UpdateUserRequest>,
) -> Result<Json<crate::test::User>, tonic_rest::RestError>
where
    S: crate::test::event_service_server::EventService + Send + Sync + 'static,
{
    body.user_id = Some(crate::core::Uuid { value: user_id_value });
    let ext = ext.map(|Extension(v)| v);
    let req = tonic_rest::build_tonic_request(body, &headers, ext);
    let response = service.update_user(req).await.map_err(tonic_rest::RestError::from)?;
    Ok(Json(response.into_inner()))
}


// =============================================================================
// Public REST paths (bypass auth middleware)
// =============================================================================

/// REST paths that are marked as public (no authentication required).
///
/// Auto-generated from `google.api.http` annotations on public RPC methods.
/// Used by middleware to identify unauthenticated endpoints.
pub const PUBLIC_REST_PATHS: &[&str] = &[
];

// =============================================================================
// Combined REST router
// =============================================================================

/// Build a combined Axum router with REST routes for all proto services.
///
/// Each service is generic — pass your concrete implementations as `Arc<T>`.
pub fn all_rest_routes<S0>(
    event_service: Arc<S0>,
) -> Router
where
    S0: crate::test::event_service_server::EventService + Send + Sync + 'static,
{
    Router::new()
        .merge(event_service_rest_router(event_service))
}
