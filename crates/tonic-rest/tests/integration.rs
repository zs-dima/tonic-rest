//! Integration tests — verify runtime types work together in real Axum handlers.
//!
//! These handlers mimic the structure of codegen-produced handlers to validate
//! `RestError`, `build_tonic_request`, and SSE streaming work end-to-end with
//! Axum's routing and extraction machinery.
//!
//! Auth extraction uses standard `Option<Extension<T>>` — the same pattern
//! generated by `tonic-rest-build`. The extension type is generic;
//! auth info is the most common use case.

use std::convert::Infallible;
use std::sync::Arc;

use axum::Router;
use axum::body::Body;
use axum::extract::{Extension, Json, Query, State};
use axum::http::{HeaderMap, Request, StatusCode};
use axum::response::sse::{Event, Sse};
use axum::routing::{get, post};
use futures::stream::{self, Stream, StreamExt};
use http_body_util::BodyExt;
use serde::{Deserialize, Serialize};
use tower::ServiceExt;

use tonic_rest::{RestError, build_tonic_request, sse_error_event};

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
struct TestRequest {
    name: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct TestResponse {
    id: String,
    name: String,
}

/// Unary JSON handler — POST with body, returns JSON response.
async fn json_handler(
    State(_svc): State<Arc<String>>,
    headers: HeaderMap,
    auth: Option<Extension<String>>,
    Json(body): Json<TestRequest>,
) -> Result<Json<TestResponse>, RestError> {
    let auth = auth.map(|Extension(v)| v);
    let req = build_tonic_request(body, &headers, auth);
    let inner = req.into_inner();
    Ok(Json(TestResponse {
        id: "test-123".to_string(),
        name: inner.name,
    }))
}

/// Handler that forwards auth from extensions to the response for verification.
async fn auth_echo_handler(
    State(_svc): State<Arc<String>>,
    headers: HeaderMap,
    auth: Option<Extension<String>>,
    Json(body): Json<TestRequest>,
) -> Result<Json<serde_json::Value>, RestError> {
    let auth = auth.map(|Extension(v)| v);
    let req = build_tonic_request(body, &headers, auth);
    let auth_val = req
        .extensions()
        .get::<String>()
        .cloned()
        .unwrap_or_default();
    let agent = req
        .metadata()
        .get("user-agent")
        .map(|v| v.to_str().unwrap_or("").to_string())
        .unwrap_or_default();
    Ok(Json(
        serde_json::json!({ "auth": auth_val, "user_agent": agent }),
    ))
}

/// Handler that always returns an error.
async fn error_handler(
    State(_svc): State<Arc<String>>,
    headers: HeaderMap,
    Json(_body): Json<TestRequest>,
) -> Result<Json<TestResponse>, RestError> {
    let _ = headers;
    Err(RestError::new(tonic::Status::not_found("item not found")))
}

/// SSE streaming handler — returns a finite stream of events.
async fn sse_handler(
    State(_svc): State<Arc<String>>,
    headers: HeaderMap,
    Query(_query): Query<TestRequest>,
) -> Result<Sse<impl Stream<Item = Result<Event, Infallible>>>, RestError> {
    let _ = headers;
    let items = vec![
        TestResponse {
            id: "1".to_string(),
            name: "first".to_string(),
        },
        TestResponse {
            id: "2".to_string(),
            name: "second".to_string(),
        },
    ];

    let stream = stream::iter(items).map(|item| {
        Ok::<_, Infallible>(
            Event::default()
                .json_data(&item)
                .unwrap_or_else(|_| Event::default().data("{}")),
        )
    });

    Ok(Sse::new(stream))
}

/// SSE handler that returns a stream with an interleaved error event.
async fn sse_error_stream_handler(
    State(_svc): State<Arc<String>>,
    _headers: HeaderMap,
    Query(_query): Query<TestRequest>,
) -> Result<Sse<impl Stream<Item = Result<Event, Infallible>>>, RestError> {
    let stream = stream::iter(vec![
        Ok::<_, Infallible>(
            Event::default()
                .json_data(&TestResponse {
                    id: "1".to_string(),
                    name: "ok".to_string(),
                })
                .unwrap(),
        ),
        Ok(sse_error_event(&tonic::Status::internal("stream failed"))),
    ]);

    Ok(Sse::new(stream))
}

/// SSE handler that rejects with `RestError` before streaming starts.
async fn sse_reject_handler(
    State(_svc): State<Arc<String>>,
    _headers: HeaderMap,
    Query(_query): Query<TestRequest>,
) -> Result<Sse<impl Stream<Item = Result<Event, Infallible>>>, RestError> {
    // Return the error early, before constructing a stream.
    // The explicit `return` avoids a turbofish on `Err` for the complex `Sse<impl Stream>` type.
    return Err(RestError::new(tonic::Status::unauthenticated(
        "not logged in",
    )));

    #[allow(unreachable_code)]
    Ok(Sse::new(stream::empty()))
}

fn app() -> Router {
    let svc = Arc::new("test-service".to_string());
    Router::new()
        .route("/items", post(json_handler))
        .route("/auth-echo", post(auth_echo_handler))
        .route("/error", post(error_handler))
        .route("/events", get(sse_handler))
        .route("/events-error", get(sse_error_stream_handler))
        .route("/events-reject", get(sse_reject_handler))
        .with_state(svc)
}

#[tokio::test]
async fn json_endpoint_returns_ok() {
    let response = app()
        .oneshot(
            Request::builder()
                .method("POST")
                .uri("/items")
                .header("content-type", "application/json")
                .body(Body::from(r#"{"name":"widget"}"#))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    assert_eq!(json["id"], "test-123");
    assert_eq!(json["name"], "widget");
}

#[tokio::test]
async fn error_endpoint_returns_json_error() {
    let response = app()
        .oneshot(
            Request::builder()
                .method("POST")
                .uri("/error")
                .header("content-type", "application/json")
                .body(Body::from(r#"{"name":"x"}"#))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::NOT_FOUND);

    let ct = response
        .headers()
        .get("content-type")
        .unwrap()
        .to_str()
        .unwrap();
    assert!(ct.contains("application/json"), "expected JSON, got: {ct}");

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    assert_eq!(json["error"]["code"], 404);
    assert_eq!(json["error"]["message"], "item not found");
    assert_eq!(json["error"]["status"], "NOT_FOUND");
}

#[tokio::test]
async fn auth_forwarded_through_build_tonic_request() {
    let mut request = Request::builder()
        .method("POST")
        .uri("/auth-echo")
        .header("content-type", "application/json")
        .header("user-agent", "IntegrationTest/1.0")
        .body(Body::from(r#"{"name":"echo"}"#))
        .unwrap();

    // Simulate auth middleware inserting auth info into extensions.
    request.extensions_mut().insert("admin-user".to_string());

    let response = app().oneshot(request).await.unwrap();
    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    assert_eq!(json["auth"], "admin-user");
    assert_eq!(json["user_agent"], "IntegrationTest/1.0");
}

#[tokio::test]
async fn sse_endpoint_streams_events() {
    let response = app()
        .oneshot(
            Request::builder()
                .method("GET")
                .uri("/events?name=test")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
    let ct = response
        .headers()
        .get("content-type")
        .unwrap()
        .to_str()
        .unwrap();
    assert!(
        ct.contains("text/event-stream"),
        "expected text/event-stream, got: {ct}",
    );

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let text = String::from_utf8(body.to_vec()).unwrap();

    // Verify both items are in the SSE output.
    assert!(text.contains("\"id\":\"1\""), "missing item 1: {text}");
    assert!(text.contains("\"id\":\"2\""), "missing item 2: {text}");
    assert!(text.contains("\"name\":\"first\""), "missing first: {text}",);
    assert!(
        text.contains("\"name\":\"second\""),
        "missing second: {text}",
    );
}

#[tokio::test]
async fn sse_error_event_in_stream() {
    let response = app()
        .oneshot(
            Request::builder()
                .method("GET")
                .uri("/events-error?name=x")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let text = String::from_utf8(body.to_vec()).unwrap();

    // First event is normal data.
    assert!(
        text.contains("\"id\":\"1\""),
        "missing normal event: {text}"
    );
    // Second event is an error event.
    assert!(
        text.contains("event: error"),
        "missing error event type: {text}",
    );
    assert!(
        text.contains("\"code\":500"),
        "missing error HTTP code: {text}",
    );
    assert!(
        text.contains("\"message\":\"stream failed\""),
        "missing error message: {text}",
    );
}

#[tokio::test]
async fn sse_reject_before_stream_returns_json_error() {
    let response = app()
        .oneshot(
            Request::builder()
                .method("GET")
                .uri("/events-reject?name=x")
                .body(Body::empty())
                .unwrap(),
        )
        .await
        .unwrap();

    // RestError rejection returns HTTP 401, not SSE.
    assert_eq!(response.status(), StatusCode::UNAUTHORIZED);

    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    assert_eq!(json["error"]["code"], 401);
    assert_eq!(json["error"]["message"], "not logged in");
}

#[tokio::test]
async fn json_endpoint_without_auth_extension() {
    // No auth info inserted into extensions → Option<Extension<T>> gives None.
    let response = app()
        .oneshot(
            Request::builder()
                .method("POST")
                .uri("/auth-echo")
                .header("content-type", "application/json")
                .body(Body::from(r#"{"name":"no-auth"}"#))
                .unwrap(),
        )
        .await
        .unwrap();

    assert_eq!(response.status(), StatusCode::OK);
    let body = response.into_body().collect().await.unwrap().to_bytes();
    let json: serde_json::Value = serde_json::from_slice(&body).unwrap();
    // Auth should be empty string (our handler defaults to "").
    assert_eq!(json["auth"], "");
}
